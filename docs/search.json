[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Tutorials",
    "section": "",
    "text": "Giới thiệu\nĐây là tập hợp các tutorial cho ngôn ngữ R. Trong khi pytutor cung cấp tutorial để tiếp cận Python một cách toàn diện, rtutor tập trung vào đơn giản hóa các khái niệm phức tạp nhưng có tính ứng dụng cao trong R."
  },
  {
    "objectID": "01_dataframe_tibble.html#tên-hàng",
    "href": "01_dataframe_tibble.html#tên-hàng",
    "title": "1  So sánh data frame và tibble",
    "section": "1.1 Tên hàng",
    "text": "1.1 Tên hàng\nTrong khi data frame có tên hàng, tibble không có.\n\nrownames(d) <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nd\n\n  a b\na 1 1\nb 0 2\nc 1 3\nd 0 4\ne 0 5\n\n\n\nd_tib <- tibble(d)\nd_tib\n\n# A tibble: 5 × 2\n      a     b\n  <dbl> <int>\n1     1     1\n2     0     2\n3     1     3\n4     0     4\n5     0     5\n\n\nMuốn thêm tên hàng cho tibble, chúng ta tạo một cột mới.\n\nd_tib <- tibble(tibble::rownames_to_column(d, \"id\"))\nd_tib\n\n# A tibble: 5 × 3\n  id        a     b\n  <chr> <dbl> <int>\n1 a         1     1\n2 b         0     2\n3 c         1     3\n4 d         0     4\n5 e         0     5\n\n\nCũng vì lí do này, data frame có thể slice theo tên hàng, còn tibble thì không.\n\nd[c(\"a\", \"b\"), ]\n\n  a b\na 1 1\nb 0 2\n\n\n\nd_tib %>% filter(id %in% c(\"a\", \"b\"))\n\n# A tibble: 2 × 3\n  id        a     b\n  <chr> <dbl> <int>\n1 a         1     1\n2 b         0     2"
  },
  {
    "objectID": "01_dataframe_tibble.html#slice-cột",
    "href": "01_dataframe_tibble.html#slice-cột",
    "title": "1  So sánh data frame và tibble",
    "section": "1.2 Slice cột",
    "text": "1.2 Slice cột\nĐể truy cập vào dữ liệu của một cột trong data frame, chúng ta có những cách sau.\n\nd$a\n\n[1] 1 0 1 0 0\n\n\n\nd[, \"a\"]\n\n[1] 1 0 1 0 0\n\n\n\nd[, c(\"a\")]\n\n[1] 1 0 1 0 0\n\n\nNhững cách này trả về vector nếu chỉ slice một cột. Muốn giữ nguyên định dạng data frame (gọi là subset), chúng ta làm như sau.\n\nd[\"a\"]\n\n  a\na 1\nb 0\nc 1\nd 0\ne 0\n\n\nThêm một cặp ngoặc vuông nữa, bạn cũng sẽ lấy được vector giá trị của cột.\n\nd[[\"a\"]]\n\n[1] 1 0 1 0 0\n\n\nSlicing bằng giá trị chuỗi kí tự của tên cột thuận lợi cho lập trình.\n\ncol_name <- \"a\"\nd[[col_name]]\n\n[1] 1 0 1 0 0\n\n\nĐối với tibble, slicing luôn trả về subset.\n\nd_tib[\"a\"]\n\n# A tibble: 5 × 1\n      a\n  <dbl>\n1     1\n2     0\n3     1\n4     0\n5     0\n\n\n\nd_tib[, \"a\"]\n\n# A tibble: 5 × 1\n      a\n  <dbl>\n1     1\n2     0\n3     1\n4     0\n5     0\n\n\n\nd_tib[, c(\"a\")]\n\n# A tibble: 5 × 1\n      a\n  <dbl>\n1     1\n2     0\n3     1\n4     0\n5     0\n\n\nĐể lấy vector, bạn có thể dùng các cách sau.\n\nd_tib$a\n\n[1] 1 0 1 0 0\n\n\n\nd_tib[[\"a\"]]\n\n[1] 1 0 1 0 0\n\n\n\nd_tib %>% pull(a)\n\n[1] 1 0 1 0 0\n\n\nDo vậy, muốn lập trình với tibble, bạn có thể làm như sau.\n\nd_tib[[col_name]]\n\n[1] 1 0 1 0 0\n\n\nHoặc\n\nd_tib %>% pull(!!rlang::sym(col_name))\n\n[1] 1 0 1 0 0\n\n\nTương tự, nếu muốn subset, bạn có thể làm như trên với hàm select().\n\nd_tib %>% select(!!rlang::sym(col_name))\n\n# A tibble: 5 × 1\n      a\n  <dbl>\n1     1\n2     0\n3     1\n4     0\n5     0"
  },
  {
    "objectID": "02_purrr_map.html#ví-dụ-1",
    "href": "02_purrr_map.html#ví-dụ-1",
    "title": "2  Lặp trong R",
    "section": "2.1 Ví dụ 1",
    "text": "2.1 Ví dụ 1\n\n2.1.1 Cách lặp truyền thống\nChúng ta sẽ đến với một bài toán đơn giản để mô phỏng cho việc lặp trong R. Chúng ta có một vector v chứa các phần tử là các dữ liệu số, và chúng ta muốn cộng thêm 1 cho mỗi phần tử. Chúng ta sẽ lưu kết quả cộng vào vector v_a.\n\nv <- c(1, 2, 3)\nv_a1 <- v\n\nfor (i in v) {\n    v_a1[i] <- v[i] + 1   # cộng 1 cho mỗi phần tử thứ i của vector v\n}\n\nprint(v)\n\n[1] 1 2 3\n\nprint(v_a1)\n\n[1] 2 3 4\n\n\nThao tác trên đây mô phỏng việc sử dụng vòng lặp for để thực hiện các tính toán giống nhau lặp đi lặp lại (thao tác cơ bản thì giống nhau, tham số đầu vào có thể khác nhau). Thông thường chúng ta sẽ gói gọn các công việc này vào trong một hàm để dễ tái sử dụng cho nhiều lần khác nhau, cũng như dễ quản lí mã lệnh và chỉnh sửa khi cần. Chẳng hạn, bạn có thể viết hàm add_y() để cộng thêm y vào mỗi phần tử trong vector, và mặc định y bằng 1.\n\nadd_y <- function(x, y = 1) {\n    x + y\n}\n\nadd_y(1)\n\n[1] 2\n\n\nVòng lặp của chúng ta trở thành như sau.\n\nfor (i in v) {\n    v_a1[i] <- add_y(v[i])\n}\n\nprint(v_a1)\n\n[1] 2 3 4\n\n\n\n\n2.1.2 Sử dụng purrr::map_dbl()\nBạn có thể đơn giản hóa vòng lặp này bằng hàm map_dbl() trong thư viện purrr. Hàm này sẽ lặp qua từng phần tử của vector v, thực hiện hàm add_y() trên từng phần tử đó, và trả về một vector là kết quả thực hiện trên toàn bộ vector v. Tốc độ lặp của hàm này nhanh hơn so với việc sử dụng vòng lặp for, do không phải truy xuất bộ nhớ liên tục và các tối ưu về vectorization khác.\n\nlibrary(purrr)\n\nv_a2 <- map_dbl(v, add_y)\n\nprint(v_a2)\n\n[1] 2 3 4\n\n\nNếu bạn chỉ muốn thực hiện một phép cộng đơn giản, chúng ta có thể làm nhanh hơn nữa như dưới đây. Cách viết thẳng hàm vào trong câu lệnh mà không khai báo hàm gọi là hàm lambda hay anonymous function. Hệ sinh thái Tidyverse cho phép bạn viết tắt việc khai báo hàm lambda như dòng lệnh tiếp theo (tính ra vector v_a4), .x là đại diện cho đối số của hàm lambda (tương tự x trong function(x)).\n\nv_a3 <- map_dbl(v, function(x) x + 1)\nv_a4 <- map_dbl(v, ~ .x + 1)\n\nprint(v_a3)\n\n[1] 2 3 4\n\nprint(v_a4)\n\n[1] 2 3 4"
  },
  {
    "objectID": "02_purrr_map.html#ví-dụ-2",
    "href": "02_purrr_map.html#ví-dụ-2",
    "title": "2  Lặp trong R",
    "section": "2.2 Ví dụ 2",
    "text": "2.2 Ví dụ 2\nTrong ví dụ phức tạp hơn dưới đây, chúng ta sẽ cùng thao tác trên một data frame.\n\nlibrary(dplyr)\n\nset.seed(0)\nd <- data.frame(\n    id = seq(10),\n    a = rnorm(10),\n    b = rgamma(10, 1)\n)\n\nd %>% kable()\n\n\n\n\nid\na\nb\n\n\n\n\n1\n1.2629543\n1.1857109\n\n\n2\n-0.3262334\n0.0946191\n\n\n3\n1.3297993\n0.1572015\n\n\n4\n1.2724293\n0.3108054\n\n\n5\n0.4146414\n0.4687319\n\n\n6\n-1.5399500\n0.0681973\n\n\n7\n-0.9285670\n1.2492921\n\n\n8\n-0.2947204\n1.0081313\n\n\n9\n-0.0057672\n1.3609450\n\n\n10\n2.4046534\n1.2059882\n\n\n\n\n\nChúng ta sẽ tính tổng bình phương giá trị của tất cả các bản ghi trong một cột. Để làm việc này, chúng ta sẽ viết hàm ssq(). Hàm sapply() mà chúng ta sử dụng có tính năng tương tự hàm map_dbl(), và là một hàm sẵn có trong R.\n\nssq <- function(v) {\n    sum(sapply(v, function(x) x ^ 2))\n}\n\nssq(d$a)\n\n[1] 14.36379\n\n\nBài toán phức tạp hơn là chúng ta muốn chạy hàm này cho nhiều cột khác nhau. Bên cạnh đó mình cũng muốn trả về trung bình của tổng bình phương, và thêm tên cột vào để dễ theo dõi. Vì vậy, mình tạo thêm một hàm calc_ssq() với đối số name là tên cột mà mình muốn thực hiện các phép tính toán. Hàm này sẽ trả về một data frame có một dòng, là kết quả tính toán tương ứng với cột trong name.\n\ncalc_ssq <- function(d, name) {\n    data.frame(\n        name = name,\n        ssq = ssq(d[name])\n    ) %>%\n        mutate(\n            mean_ssq = ssq / nrow(d)\n        )\n}\n\ncalc_ssq(d, \"a\")\n\n  name      ssq mean_ssq\n1    a 14.36379 1.436379\n\n\nCái hay của purrr là nó cung cấp hàm map_df(), tự động gộp các data frame sau mỗi lần chạy vào với nhau, và tạo thành một data frame duy nhất.\n\nvars_to_calc <- c(\"a\", \"b\")\nmap_df(vars_to_calc, ~ calc_ssq(d, .x)) %>% kable()\n\n\n\n\nname\nssq\nmean_ssq\n\n\n\n\na\n14.363786\n1.4363786\n\n\nb\n7.644174\n0.7644174"
  },
  {
    "objectID": "03_categorization.html#mục-đích",
    "href": "03_categorization.html#mục-đích",
    "title": "3  Tạo nhóm từ biến liên tục",
    "section": "3.1 Mục đích",
    "text": "3.1 Mục đích\nTrong nghiên cứu, bạn thường thu thập một số biến liên tục, sau đó dựa vào các điểm cắt để phân thành các nhóm. Chẳng hạn, chúng ta thường phân loại chỉ số khối cơ thể (BMI) thành các nhóm nhẹ cân (BMI < 18.5), bình thường (18.5 - <25), thừa cân (25 - <30), và béo phì (>30). Chúng ta không nên thu thập ngay phân loại BMI, mà nên thu thập các chỉ số chiều cao và cân nặng, sau đó sử dụng phần mềm để tính ra BMI và phân nhóm.\nChúng ta sẽ cùng xem một bộ số liệu như sau.\n\nlibrary(dplyr)\n\nset.seed(0)\nn <- 10\n\nd <- data.frame(\n    id = seq(n),\n    sex = sample(c(1, 2), n, replace = TRUE),   # 1=Nam 2=Nữ\n    bmi = runif(n, 16.5, 35)\n)\n\nd %>% kable()\n\n\n\n\nid\nsex\nbmi\n\n\n\n\n1\n2\n17.64305\n\n\n2\n1\n20.31053\n\n\n3\n2\n19.76630\n\n\n4\n1\n29.20992\n\n\n5\n1\n23.60592\n\n\n6\n2\n30.74207\n\n\n7\n1\n25.70744\n\n\n8\n1\n29.77594\n\n\n9\n1\n34.85026\n\n\n10\n2\n23.53065"
  },
  {
    "objectID": "03_categorization.html#phân-nhóm-từ-một-biến-liên-tục",
    "href": "03_categorization.html#phân-nhóm-từ-một-biến-liên-tục",
    "title": "3  Tạo nhóm từ biến liên tục",
    "section": "3.2 Phân nhóm từ một biến liên tục",
    "text": "3.2 Phân nhóm từ một biến liên tục\nĐể phân loại các nhóm BMI, chúng ta chỉ cần sử dụng một biến BMI là đủ. Đặc điểm của các nhóm phân loại từ BMI là mỗi cá thể chỉ được phân loại vào đúng một nhóm. Thông thường, với cách phân loại này, chúng ta sẽ mã hóa các nhóm tăng dần từ giá trị 1 (ví dụ, 1 đến 4 cho 4 nhóm BMI).\nBạn có thể làm rất nhanh việc phân nhóm này trong R bằng việc sử dụng hàm cut(). Cung cấp cho hàm này một đối số là các khoảng giá trị điểm cắt (bao gồm cả giá trị thấp nhất và cao nhất), hàm sẽ trả về cho bạn một factor của phân nhóm tạo ra từ biến liên tục. Các đối số khác trong hàm cut() bạn tự tham khảo trong phần documentation của R nhé (gõ ?cut trong R console và ấn Enter).\n\nd$bmi %>% cut(c(0, 18.5, 25, 30, 100),\n    labels = seq(4), right = FALSE, ordered_result = TRUE)\n\n [1] 1 2 2 3 2 4 3 3 4 2\nLevels: 1 < 2 < 3 < 4\n\n\nMột cách khác tuy nhìn không thuận tiện nhưng lại thuận lợi hơn về mặt tính toán là chỉ sử dụng các biểu thức logic và số học. Chúng ta sẽ xem kết quả trước (hãy tập trung vào nội dung của hàm mutate()), sau đó mình sẽ giải thích chi tiết.\n\nd %>%\n    select(id, bmi) %>%\n    mutate(\n        bmi_group = 1 + (bmi >= 18.5) + (bmi >= 25) + (bmi >= 30)\n    ) %>%\n    kable()\n\n\n\n\nid\nbmi\nbmi_group\n\n\n\n\n1\n17.64305\n1\n\n\n2\n20.31053\n2\n\n\n3\n19.76630\n2\n\n\n4\n29.20992\n3\n\n\n5\n23.60592\n2\n\n\n6\n30.74207\n4\n\n\n7\n25.70744\n3\n\n\n8\n29.77594\n3\n\n\n9\n34.85026\n4\n\n\n10\n23.53065\n2\n\n\n\n\n\nCách làm này dựa trên nguyên tắc về phân loại mình nêu trên, đấy là mỗi bệnh nhân chỉ được phân vào một trong 4 nhóm, và các nhóm đánh số từ 1 đến 4. Theo công thức trong hàm mutate(), những người có BMI cao sẽ thỏa mãn cả các điều kiện của BMI thấp hơn, và do đó, “tổng điểm” sẽ cao hơn. Nếu chưa mường tượng ra, bạn hãy nhìn bảng dưới đây và tự suy ngẫm.\n\nd %>%\n    select(id, bmi) %>%\n    mutate(\n        bmi_2 = as.numeric(bmi >= 18.5),\n        bmi_3 = as.numeric(bmi >= 25),\n        bmi_4 = as.numeric(bmi >= 30),\n        bmi_group = 1 + (bmi >= 18.5) + (bmi >= 25) + (bmi >= 30)\n    ) %>%\n    kable()\n\n\n\n\nid\nbmi\nbmi_2\nbmi_3\nbmi_4\nbmi_group\n\n\n\n\n1\n17.64305\n0\n0\n0\n1\n\n\n2\n20.31053\n1\n0\n0\n2\n\n\n3\n19.76630\n1\n0\n0\n2\n\n\n4\n29.20992\n1\n1\n0\n3\n\n\n5\n23.60592\n1\n0\n0\n2\n\n\n6\n30.74207\n1\n1\n1\n4\n\n\n7\n25.70744\n1\n1\n0\n3\n\n\n8\n29.77594\n1\n1\n0\n3\n\n\n9\n34.85026\n1\n1\n1\n4\n\n\n10\n23.53065\n1\n0\n0\n2"
  },
  {
    "objectID": "03_categorization.html#phân-loại-từ-nhiều-biến",
    "href": "03_categorization.html#phân-loại-từ-nhiều-biến",
    "title": "3  Tạo nhóm từ biến liên tục",
    "section": "3.3 Phân loại từ nhiều biến",
    "text": "3.3 Phân loại từ nhiều biến\nNếu tiêu chí phân loại của bạn như sau:\n\n1=Nam BMI >30\n2=Nam BMI >28\n3=Nam BMI >25 và <=30 hoặc Nữ BMI >23 và <=28\n4=Còn lại\n\nthì bạn sẽ gặp khó khăn trong việc dùng công thức ở trên. Tuy nhiên, chúng ta vẫn có thể tổng quát hóa công thức toán học đó như sau.\n\nd %>%\n    mutate(\n        ploai = 1 * (sex == 1) * (bmi > 30) +\n            2 * (sex == 2) * (bmi > 28) +\n            3 * (\n                (sex == 1) * (bmi > 25) * (bmi <= 30) +\n                (sex == 2) * (bmi > 23) * (bmi <= 28)\n            ),\n        ploai = ploai * (ploai > 0) + 4 * (ploai == 0)\n    ) %>%\n    kable()\n\n\n\n\nid\nsex\nbmi\nploai\n\n\n\n\n1\n2\n17.64305\n4\n\n\n2\n1\n20.31053\n4\n\n\n3\n2\n19.76630\n4\n\n\n4\n1\n29.20992\n3\n\n\n5\n1\n23.60592\n4\n\n\n6\n2\n30.74207\n2\n\n\n7\n1\n25.70744\n3\n\n\n8\n1\n29.77594\n3\n\n\n9\n1\n34.85026\n1\n\n\n10\n2\n23.53065\n3\n\n\n\n\n\nTư duy trong giải pháp này là bạn có thể tạo ra các phân nhóm chỉ từ phép cộng và phép nhân. Phép nhân sẽ tương đương với toán tử AND (nếu A và B chỉ là 0 hoặc 1 thì A AND B = 1 khi và chỉ khi A = B = 1), còn phép cộng sẽ tương đương với toán tử OR nếu như A và B không bao giờ đồng thời bằng 1 (khi đó A OR B = 0 khi và chỉ khi A = B = 0). Và khi một trường hợp là đúng (TRUE, =1), bạn chỉ cần nhân với code tương ứng của nó, thế là xong. Để thực hiện theo cách này, chúng ta cần đảm bảo các chuỗi điều kiện chỉ đúng cho một trong các phân nhóm; nếu có nhiều phân nhóm cùng đúng (một người có thể thuộc về nhiều nhóm) thì lệnh sẽ tạo ra các code mới ngoài dự kiến (là tổng của các phân nhóm thỏa mãn điều kiện).\nBạn có thể dùng hàm case_when() để đơn giản hóa biểu thức tính toán ở trên.\n\nd %>%\n    mutate(\n        ploai = case_when(\n            (sex == 1) & (bmi > 30) ~ 1,\n            (sex == 2) & (bmi > 28) ~ 2,\n            (sex == 1) & (bmi > 25) | (sex == 2) & (bmi > 23) ~ 3,\n            TRUE ~ 4\n        )\n    ) %>%\n    kable()\n\n\n\n\nid\nsex\nbmi\nploai\n\n\n\n\n1\n2\n17.64305\n4\n\n\n2\n1\n20.31053\n4\n\n\n3\n2\n19.76630\n4\n\n\n4\n1\n29.20992\n3\n\n\n5\n1\n23.60592\n4\n\n\n6\n2\n30.74207\n2\n\n\n7\n1\n25.70744\n3\n\n\n8\n1\n29.77594\n3\n\n\n9\n1\n34.85026\n1\n\n\n10\n2\n23.53065\n3\n\n\n\n\n\nCách làm của hàm case_when() sẽ giúp bạn bớt đi được một số điều kiện (ví dụ, ở nhóm 3 bạn không cần thêm điều kiện BMI <=30 cho nam và <=28 cho nữ). Khi các điều kiện cho nhóm 1 và 2 không thỏa mãn, thì điều kiện BMI <= 30 hoặc 28 đã tự động được thỏa mãn."
  },
  {
    "objectID": "04_data_manipulation.html#bài-toán",
    "href": "04_data_manipulation.html#bài-toán",
    "title": "4  Tư duy thao tác dữ liệu trong R",
    "section": "4.1 Bài toán",
    "text": "4.1 Bài toán\nHôm nay mình sẽ giới thiệu với các bạn một bài toán phân tích số liệu đơn giản trong R. Bài toán này nhằm giúp các bạn hiểu rõ hơn cách thức tư duy khi giải quyết một bài toán bằng lập trình.\nChúng ta có một bộ số liệu với 4 biến là stt (số thứ tự), gioi (giới: Nam, Nữ), do_tuoi (độ tuổi: <18, 18-45, >45), hailong (điểm hài lòng, từ 0 đến 100), và qol (điểm chất lượng cuộc sống, từ 0 đến 100). Đây là một bộ số liệu do mình tạo ra ngẫu nhiên ra thôi.\n\nlibrary(dplyr)\nlibrary(tidyr)\n\nset.seed(0)\nn <- 1000\n\nd <- data.frame(\n    stt = seq(n),\n    gioi = factor(sample(c(1, 2), n, TRUE),\n        levels = c(1, 2), labels = c(\"Nam\", \"Nu\")),\n    do_tuoi = factor(sample(c(1, 2, 3), n, TRUE),\n        levels = c(1, 2, 3), labels = c(\"<18\", \"18-45\", \">45\")),\n    hailong = round(runif(n, 0, 100), 1),\n    qol = round(runif(n, 0, 100), 1)\n)\n\nd %>% head(5) %>% kable()\n\n\n\n\nstt\ngioi\ndo_tuoi\nhailong\nqol\n\n\n\n\n1\nNu\n>45\n33.0\n76.3\n\n\n2\nNam\n>45\n69.7\n23.6\n\n\n3\nNu\n>45\n35.4\n28.6\n\n\n4\nNam\n<18\n40.6\n31.8\n\n\n5\nNam\n>45\n30.8\n92.2\n\n\n\n\n\nViệc của chúng ta sẽ là tạo ra một bảng phân tích kết quả trông như sau:\n\n\n\nĐặc điểm\nNhóm\nHài lòng, mean (SD)\n\n\n\n\nGiới\nNam\n…\n\n\nGiới\nNữ\n…\n\n\nĐộ tuổi\n<18\n…\n\n\nĐộ tuổi\n18-45\n…\n\n\nĐộ tuổi\n>45\n…\n\n\n\nCó nhiều cách để làm việc này. Cách mà mình giới thiệu hôm nay khá trực tiếp, mặc dù có thể không phải là cách tối ưu."
  },
  {
    "objectID": "04_data_manipulation.html#các-phép-thao-tác-với-số-liệu",
    "href": "04_data_manipulation.html#các-phép-thao-tác-với-số-liệu",
    "title": "4  Tư duy thao tác dữ liệu trong R",
    "section": "4.2 Các phép thao tác với số liệu",
    "text": "4.2 Các phép thao tác với số liệu\nCó 4 phép thao tác (manipulate) số liệu chính:\n\nTái cấu trúc (reshaping): chuyển số liệu từ dạng bảng dài sang dạng bảng ngang và ngược lại (pivot giữa long / wide data), xếp chồng các số liệu lên nhau (stacking / unstacking), v.v.. Thư viện sử dụng cho reshaping là tidyr.\nNhóm (grouping): các số liệu thuộc cùng một nhóm được xếp chung với nhau để phục vụ một mục đích nào đó. Bạn chắc đã làm quen với hàm dplyr::group_by() cho việc này.\nChuyển dạng (transformation): chuyển số liệu cá thể thành các giá trị mới dựa trên một phép biến đổi nào đó như chuẩn hóa (normalization), logarit, chia nhóm (categorization), v.v.. Mọi phép chuyển dạng đều thông qua hàm dplyr::mutate() và các biến thể của nó.\nTổng hợp (aggregation): tính toán các chỉ số tổng hợp (trung bình, tỉ lệ phần trăm, v.v.) từ số liệu cá thể. Hầu hết các phép tổng hợp đều thông qua hàm dplyr::summarize() và các biến thể của nó.\n\nBằng những phép thao tác số liệu này, chúng ta có thể tạo ra mọi kết quả mong muốn từ một bộ số liệu gốc."
  },
  {
    "objectID": "04_data_manipulation.html#tư-duy-thao-tác-số-liệu",
    "href": "04_data_manipulation.html#tư-duy-thao-tác-số-liệu",
    "title": "4  Tư duy thao tác dữ liệu trong R",
    "section": "4.3 Tư duy thao tác số liệu",
    "text": "4.3 Tư duy thao tác số liệu\nNhìn vào bộ số liệu gốc, mình nghĩ rằng sẽ cần tạo ra một (hoặc nhiều) bộ số liệu trung gian để phục vụ việc tính toán như trên. Bộ số liệu trung gian sẽ có cấu trúc như thế nào? Quan sát bảng phân tích kết quả, chúng ta thấy rằng:\n\nCột “Đặc điểm” là tên các biến mà chúng ta có trong bộ số liệu gốc.\nCột “Nhóm” là các giá trị của các biến “Đặc điểm” có trong bộ số liệu gốc.\nCột “Hài lòng” là kết quả tổng hợp của điểm hài lòng trong bộ số liệu gốc.\n\nVậy bộ số liệu trung gian của mình có thể là kết quả chuyển từ dạng ngang (các biến xếp thành từng cột) sang dạng dài (các biến xếp chồng lên nhau) của hai biến gioi và do_tuoi, còn giữ lại biến hailong. Ví dụ:\n\n\n\nstt\nvariable\nvalue\nhailong\n\n\n\n\n1\ngioi\nNu\n33.0\n\n\n1\ndo_tuoi\n>45\n33.0\n\n\n2\ngioi\nNam\n69.7\n\n\n2\ndo_tuoi\n>45\n69.7\n\n\n\nSau đó mình chỉ việc tạo ra các nhóm của Đặc điểm (variable) và Nhóm (value) để tổng hợp (aggregate) cột hailong. Hãy cùng xem chúng ta thực thi kế hoạch này.\n\n4.3.1 Bước 1: Reshaping\n\nd_long <- d %>%\n    select(gioi, do_tuoi, hailong) %>%\n    pivot_longer(cols = c(gioi, do_tuoi), names_to = \"variable\")\n\nd_long %>% head() %>% kable()\n\n\n\n\nhailong\nvariable\nvalue\n\n\n\n\n33.0\ngioi\nNu\n\n\n33.0\ndo_tuoi\n>45\n\n\n69.7\ngioi\nNam\n\n\n69.7\ndo_tuoi\n>45\n\n\n35.4\ngioi\nNu\n\n\n35.4\ndo_tuoi\n>45\n\n\n\n\n\n\n\n4.3.2 Bước 2: Grouping và Aggregation\n\nd_agg <- d_long %>%\n    group_by(variable, value) %>%\n    summarize(\n        mean = mean(hailong),\n        sd = sd(hailong)\n    )\n\nd_agg %>% kable()\n\n\n\n\nvariable\nvalue\nmean\nsd\n\n\n\n\ndo_tuoi\n<18\n49.97685\n28.50213\n\n\ndo_tuoi\n18-45\n50.87988\n29.54522\n\n\ndo_tuoi\n>45\n49.84675\n28.96249\n\n\ngioi\nNam\n49.64345\n29.21245\n\n\ngioi\nNu\n50.84234\n28.77515\n\n\n\n\n\n\n\n4.3.3 Bước 3: Transformation\n\nd_agg %>%\n    mutate(\n        mean_sd = sprintf(\"%.1f (%.1f)\", mean, sd)\n    ) %>%\n    select(variable, value, mean_sd) %>%\n    kable()\n\n\n\n\nvariable\nvalue\nmean_sd\n\n\n\n\ndo_tuoi\n<18\n50.0 (28.5)\n\n\ndo_tuoi\n18-45\n50.9 (29.5)\n\n\ndo_tuoi\n>45\n49.8 (29.0)\n\n\ngioi\nNam\n49.6 (29.2)\n\n\ngioi\nNu\n50.8 (28.8)"
  },
  {
    "objectID": "04_data_manipulation.html#module-hóa-công-việc",
    "href": "04_data_manipulation.html#module-hóa-công-việc",
    "title": "4  Tư duy thao tác dữ liệu trong R",
    "section": "4.4 Module hóa công việc",
    "text": "4.4 Module hóa công việc\nNhư ở trên, bạn đã thấy chúng ta thống kê được mean (SD) của điểm hài lòng. Nhưng nếu chúng ta muốn làm tương tự như vậy với điểm chất lượng cuộc sống và gộp chung kết quả với điểm hài lòng thì bạn sẽ làm thế nào? Tất nhiên, bạn hoàn toàn có thể thêm tạo ra các biến mean_qol và sd_qol cho điểm chất lượng cuộc sống trong Bước 2, nhưng nếu không phải là 2 biến mà là 20 biến, thì việc đó sẽ rất phiền toái, hoặc nếu bạn phải thay đổi kế hoạch phân tích, loại bỏ biến qol và thêm biến khác vào. Đây là lúc bạn cần dùng đến hàm, và chúng ta gọi đây là module hóa công việc.\nBa bước ở trên có thể được tóm gọn trong một hàm như sau.\n\nlibrary(rlang)\n\nget_mean_sd <- function(d, group_vars, outcome_var) {\n    d %>%\n        # Bước 1\n        select(all_of(c(group_vars, outcome_var))) %>%\n        pivot_longer(cols = all_of(group_vars), names_to = \"variable\") %>%\n\n        # Bước 2\n        group_by(variable, value) %>%\n        summarize(\n            mean = mean(!!sym(outcome_var)),\n            sd = sd(!!sym(outcome_var))\n        ) %>%\n\n        # Bước 3\n        mutate(\n            outcome = outcome_var,\n            mean_sd = sprintf(\"%.1f (%.1f)\", mean, sd)\n        ) %>%\n        select(variable, value, outcome, mean_sd)\n}\n\ngroup_vars <- c(\"gioi\", \"do_tuoi\")\noutcome_var <- \"hailong\"\nget_mean_sd(d, group_vars, outcome_var) %>% kable()\n\n\n\n\nvariable\nvalue\noutcome\nmean_sd\n\n\n\n\ndo_tuoi\n<18\nhailong\n50.0 (28.5)\n\n\ndo_tuoi\n18-45\nhailong\n50.9 (29.5)\n\n\ndo_tuoi\n>45\nhailong\n49.8 (29.0)\n\n\ngioi\nNam\nhailong\n49.6 (29.2)\n\n\ngioi\nNu\nhailong\n50.8 (28.8)\n\n\n\n\n\nVà chúng ta có thể tự động hóa việc tính toán này cho nhiều biến kết cục khác nhau.\n\nlibrary(purrr)\n\noutcome_vars <- c(\"hailong\", \"qol\")\nmap_df(outcome_vars, ~ get_mean_sd(d, group_vars, .x)) %>% kable()\n\n\n\n\nvariable\nvalue\noutcome\nmean_sd\n\n\n\n\ndo_tuoi\n<18\nhailong\n50.0 (28.5)\n\n\ndo_tuoi\n18-45\nhailong\n50.9 (29.5)\n\n\ndo_tuoi\n>45\nhailong\n49.8 (29.0)\n\n\ngioi\nNam\nhailong\n49.6 (29.2)\n\n\ngioi\nNu\nhailong\n50.8 (28.8)\n\n\ndo_tuoi\n<18\nqol\n49.3 (30.0)\n\n\ndo_tuoi\n18-45\nqol\n48.7 (30.4)\n\n\ndo_tuoi\n>45\nqol\n49.3 (30.7)\n\n\ngioi\nNam\nqol\n49.9 (29.7)\n\n\ngioi\nNu\nqol\n48.4 (31.0)\n\n\n\n\n\nTất nhiên, nếu bạn muốn chuyển sang dạng nhiều cột kết quả của các biến kết cục thì cũng rất đơn giản, nó chỉ là pivot từ dạng long sang wide thôi.\n\nmap_df(outcome_vars, ~ get_mean_sd(d, group_vars, .x)) %>%\n    pivot_wider(id_cols = c(variable, value),\n        names_from = outcome, values_from = mean_sd) %>%\n    kable()\n\n\n\n\nvariable\nvalue\nhailong\nqol\n\n\n\n\ndo_tuoi\n<18\n50.0 (28.5)\n49.3 (30.0)\n\n\ndo_tuoi\n18-45\n50.9 (29.5)\n48.7 (30.4)\n\n\ndo_tuoi\n>45\n49.8 (29.0)\n49.3 (30.7)\n\n\ngioi\nNam\n49.6 (29.2)\n49.9 (29.7)\n\n\ngioi\nNu\n50.8 (28.8)\n48.4 (31.0)\n\n\n\n\n\nVà bạn có thể gói tiếp chức năng này trong một hàm như sau:\n\nget_mean_sd_all <- function(d, group_vars, outcome_vars) {\n    map_df(outcome_vars, ~ get_mean_sd(d, group_vars, .x)) %>%\n        pivot_wider(id_cols = c(variable, value),\n            names_from = outcome, values_from = mean_sd)\n}\n\nget_mean_sd_all(d, group_vars, outcome_vars) %>% kable()\n\n\n\n\nvariable\nvalue\nhailong\nqol\n\n\n\n\ndo_tuoi\n<18\n50.0 (28.5)\n49.3 (30.0)\n\n\ndo_tuoi\n18-45\n50.9 (29.5)\n48.7 (30.4)\n\n\ndo_tuoi\n>45\n49.8 (29.0)\n49.3 (30.7)\n\n\ngioi\nNam\n49.6 (29.2)\n49.9 (29.7)\n\n\ngioi\nNu\n50.8 (28.8)\n48.4 (31.0)\n\n\n\n\n\nNhững tính năng thuộc về lập trình cho dplyr và purrr như dấu chấm than kép (!!), hàm rlang::sym(), hàm dplyr::all_of(), và hàm purrr:map_df() mình sẽ giới thiệu cụ thể trong một bài khác. Chúng ta sẽ dừng lại bài này ở đây, vì hi vọng bạn đã hiểu rõ hơn cách chúng ta tư duy khi lập trình để thao tác với số liệu. Mình tổng hợp lại kết quả ở dưới đây nhé.\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(rlang)\nlibrary(purrr)\n\n# Tính mean (SD) cho một biến\nget_mean_sd <- function(d, group_vars, outcome_var) {\n    d %>%\n        # Bước 1\n        select(all_of(c(group_vars, outcome_var))) %>%\n        pivot_longer(cols = all_of(group_vars), names_to = \"variable\") %>%\n\n        # Bước 2\n        group_by(variable, value) %>%\n        summarize(\n            mean = mean(!!sym(outcome_var)),\n            sd = sd(!!sym(outcome_var))\n        ) %>%\n\n        # Bước 3\n        mutate(\n            outcome = outcome_var,\n            mean_sd = sprintf(\"%.1f (%.1f)\", mean, sd)\n        ) %>%\n        select(variable, value, outcome, mean_sd)\n}\n\n# Tính mean (SD) cho tất cả các biến\nget_mean_sd_all <- function(d, group_vars, outcome_vars) {\n    map_df(outcome_vars, ~ get_mean_sd(d, group_vars, .x)) %>%\n        pivot_wider(id_cols = c(variable, value),\n            names_from = outcome, values_from = mean_sd)\n}\n\ngroup_vars <- c(\"gioi\", \"do_tuoi\")\noutcome_vars <- c(\"hailong\", \"qol\")\nget_mean_sd_all(d, group_vars, outcome_vars)"
  },
  {
    "objectID": "05_func_ggplot.html#bài-toán",
    "href": "05_func_ggplot.html#bài-toán",
    "title": "5  Sử dụng hàm trong R để tối ưu hóa công việc",
    "section": "5.1 Bài toán",
    "text": "5.1 Bài toán\nHôm nay chúng ta sẽ nói về việc sử dụng hàm trong R. Chúng ta sẽ cùng tìm hiểu khi nào nên sử dụng hàm và vai trò của nó trong việc tối ưu hóa việc lập trình.\nChúng ta sẽ có một cơ sở dữ liệu gồm các biến gioi (Nam/Nữ), do_tuoi (ba nhóm độ tuổi), hb (nồng độ hemoglobin), và rbc (số lượng hồng cầu).\n\nlibrary(dplyr)\nlibrary(tidyr)\n\nset.seed(0)\nn <- 1000\n\nd <- data.frame(\n    stt = seq(n),\n    gioi = factor(sample(c(1, 2), n, TRUE),\n        levels = c(1, 2), labels = c(\"Nam\", \"Nu\")),\n    do_tuoi = factor(sample(c(1, 2, 3), n, TRUE),\n        levels = c(1, 2, 3), labels = c(\"<18\", \"18-45\", \">45\"))\n) %>%\n    mutate(\n        hb = round(rnorm(n, 130, 10) + 5 * (gioi == \"Nam\") - 3.5 * (do_tuoi == \">45\"), 1),\n        rbc = round(rnorm(n, 4, 0.5) + 0.25 * (gioi == \"Nam\") - 0.1 * (do_tuoi == \">45\"), 2)\n    )\n\nd %>% head(10) %>% kable()\n\n\n\n\nstt\ngioi\ndo_tuoi\nhb\nrbc\n\n\n\n\n1\nNu\n>45\n122.1\n3.93\n\n\n2\nNam\n>45\n127.7\n4.95\n\n\n3\nNu\n>45\n121.5\n3.89\n\n\n4\nNam\n<18\n140.0\n3.98\n\n\n5\nNam\n>45\n146.7\n5.14\n\n\n6\nNu\n<18\n139.9\n3.32\n\n\n7\nNam\n18-45\n147.5\n4.46\n\n\n8\nNam\n<18\n131.7\n3.76\n\n\n9\nNam\n18-45\n143.4\n4.85\n\n\n10\nNu\n18-45\n120.2\n4.22\n\n\n\n\n\nChúng ta sẽ vẽ biểu đồ histogram cho các biến hb và rbc."
  },
  {
    "objectID": "05_func_ggplot.html#vẽ-biểu-đồ-bằng-ggplot2",
    "href": "05_func_ggplot.html#vẽ-biểu-đồ-bằng-ggplot2",
    "title": "5  Sử dụng hàm trong R để tối ưu hóa công việc",
    "section": "5.2 Vẽ biểu đồ bằng ggplot2",
    "text": "5.2 Vẽ biểu đồ bằng ggplot2\nThư viện ggplot2 cung cấp cho chúng ta một engine đồ họa mạnh với khả năng tùy biến cao. Hãy cùng nhau vẽ một biểu đồ histogram cho biến hb và sau đó tùy biến nó. Đầu tiên, chúng ta sẽ dùng tối thiểu số lệnh cần để vẽ biểu đồ này. Lưu ý: trong bài này mình không giới thiệu tính năng các hàm trong ggplot2, bạn sẽ phải tự tìm hiểu ở những khóa học khác.\n\nlibrary(ggplot2)\n\nggplot(d, aes(x = hb)) +\n    geom_histogram()\n\n\n\n\nCó một số tùy biến mà chúng ta thường sẽ muốn thiết lập để biểu đồ nhìn có thẩm mỹ hơn. Chẳng hạn, mình muốn chuyển sang theme đen-trắng, loại bỏ các đường dóng, đổi tên trục biểu đồ, và thêm ghi chú.\n\nggplot(d, aes(x = hb)) +\n    geom_histogram() +\n    theme_bw() +\n    theme(panel.grid = element_blank()) +\n    labs(\n        x = \"Nồng độ hemoglobin (g/L)\",\n        y = \"\",\n        caption = \"Biểu đồ histogram thể hiện phân bố\\ncác giá trị của quần thể nghiên cứu.\"\n    )\n\n\n\n\nMình chợt nhận ra là mình muốn thêm đường thẳng thể hiện trung bình của nồng độ hemoglobin vào biểu đồ này, và thay đổi màu sắc của histogram.\n\nggplot(d, aes(x = hb)) +\n    geom_histogram(fill = \"#afac9c\") +\n    geom_vline(\n        aes(\n            xintercept = d %>% pull(hb) %>% mean(na.rm = TRUE),\n            color = \"mean\"\n        )\n    ) +\n    theme_bw() +\n    theme(\n        panel.grid = element_blank(),\n        legend.position = c(0.98, 0.98),\n        legend.justification = c(\"right\", \"center\"),\n        legend.title = element_blank()\n    ) +\n    labs(\n        x = \"Nồng độ hemoglobin (g/L)\",\n        y = \"\",\n        caption = \"Biểu đồ histogram thể hiện phân bố\\ncác giá trị của quần thể nghiên cứu.\"\n    ) +\n    scale_color_manual(\n        values = c(mean = \"#d28872\"),\n        labels = c(mean = \"Trung bình\")\n    )\n\n\n\n\nBây giờ chúng ta sẽ vẽ tương tự cho biến rbc. Bạn nhận ra rằng mình sẽ sao chép lại một đoạn mã lệnh rất dài. Và giả sử mình muốn sử dụng những màu sắc khác cho histogram và đường trung bình, mình sẽ phải chỉnh sửa lại các dòng lệnh liên quan.\n\nggplot(d, aes(x = rbc)) +\n    geom_histogram(fill = \"#f0cf6d\") +\n    geom_vline(\n        aes(\n            xintercept = d %>% pull(rbc) %>% mean(na.rm = TRUE),\n            color = \"mean\"\n        )\n    ) +\n    theme_bw() +\n    theme(\n        panel.grid = element_blank(),\n        legend.position = c(0.98, 0.98),\n        legend.justification = c(\"right\", \"center\"),\n        legend.title = element_blank()\n    ) +\n    labs(\n        x = \"Số lượng hồng cầu (T/L)\",\n        y = \"\",\n        caption = \"Biểu đồ histogram thể hiện phân bố\\ncác giá trị của quần thể nghiên cứu.\"\n    ) +\n    scale_color_manual(\n        values = c(mean = \"#4197a5\"),\n        labels = c(mean = \"Trung bình\")\n    )"
  },
  {
    "objectID": "05_func_ggplot.html#đóng-gói-công-việc-bằng-hàm",
    "href": "05_func_ggplot.html#đóng-gói-công-việc-bằng-hàm",
    "title": "5  Sử dụng hàm trong R để tối ưu hóa công việc",
    "section": "5.3 Đóng gói công việc bằng hàm",
    "text": "5.3 Đóng gói công việc bằng hàm\nChúng ta đã thực hiện các công việc sau đây:\n\nKhởi tạo một biểu đồ\nVẽ histogram\nVẽ đường thẳng trung bình\nĐịnh dạng lại biểu đồ\n\nBạn có thể thấy rằng tất cả các dòng lệnh cho công việc này nối với nhau bằng toán tử +:\n<công_việc_1> +\n    <công_việc_2> +\n    <công_việc_3> +\n    ...\nHãy cùng nhau gói các công việc này vào trong hàm. Để thuận tiện, mình sẽ gói công việc khởi tạo biểu đồ và định dạng chung vào một hàm.\n\nlibrary(rlang)\n\n# Công việc 1: Khởi tạo biểu đồ\nplot_create <- function(data) {\n    ggplot(data) +\n        theme_bw() +\n        theme(\n            panel.grid = element_blank()\n        )\n}\n\n# Công việc 2: Vẽ histogram\nplot_histogram <- function(g, var_name, var_label, bar_fill) {\n    g +\n        geom_histogram(\n            aes(x = !!sym(var_name)),\n            fill = bar_fill\n        ) +\n        labs(\n            x = var_label,\n            y = \"\",\n            caption = \"Biểu đồ histogram thể hiện phân bố\\ncác giá trị của quần thể nghiên cứu.\"\n        )\n}\n\n# Công việc 3: Vẽ đường thẳng trung bình\nplot_mean <- function(g, data, var_name, line_color) {\n    g +\n        geom_vline(\n            aes(\n                xintercept = data %>% pull(!!sym(var_name)) %>% mean(na.rm = TRUE),\n                # Có cách làm khác sử dụng stat_summary(),\n                # bạn tự tìm hiểu nhé.\n                color = \"mean\"\n            )\n        ) +\n        scale_color_manual(\n            values = c(mean = line_color),\n            labels = c(mean = \"Trung bình\")\n        ) +\n        theme(\n            legend.position = c(0.98, 0.98),\n            legend.justification = c(\"right\", \"center\"),\n            legend.title = element_blank()\n        )\n}\n\nSau khi đã xây dựng xong các hàm này, chúng ta có thể vẽ như ý muốn. Với biểu đồ cho hemoglobin, mình không muốn vẽ đường thẳng trung bình.\n\nvar_name <- \"hb\"\nvar_label <- \"Nồng độ hemoglobin (g/L)\"\nbar_fill <- \"#afac9c\"\n\nplot_create(d) %>%\n    plot_histogram(var_name, var_label, bar_fill)\n\n\n\n\nNhưng với biểu đồ cho hồng cầu, mình sẽ vẽ đường thẳng trung bình, và giữ nguyên thiết lập màu sắc của biểu đồ trước.\n\nvar_name <- \"rbc\"\nvar_label <- \"Số lượng hồng cầu (T/L)\"\nline_color <- \"#d28872\"\n\nplot_create(d) %>%\n    plot_histogram(var_name, var_label, bar_fill) %>%\n    plot_mean(d, var_name, line_color)\n\n\n\n\n\n5.3.1 Vẽ nhiều biểu đồ cho dưới nhóm\nGiả sử bạn muốn vẽ hai biểu đồ histogram của hb cho hai nhóm giới tính. Chúng ta dễ dàng được điều này với hàm facet_wrap().\n\nplot_subgroup <- function(g, var_subgroup, ncol = 2) {\n    g +\n        facet_wrap(vars(!!sym(var_subgroup)), ncol = ncol, scales = \"free\")\n}\n\nvar_name <- \"hb\"\nvar_label <- \"Nồng độ hemoglobin (g/L)\"\nbar_fill <- \"#afac9c\"\nline_color <- \"#d28872\"\nvar_subgroup <- \"gioi\"\n\nplot_create(d) %>%\n    plot_histogram(var_name, var_label, bar_fill) %>%\n    plot_mean(d, var_name, line_color) %>%\n    plot_subgroup(var_subgroup)\n\n\n\n\n\n\n5.3.2 Vẽ nhiều biểu đồ cho nhiều biến\nBạn sẽ tự hỏi liệu có thể làm tương tự nhưng vẽ hai biểu đồ cho hai biến hb và rbc được không? Câu trả lời là chúng ta sẽ cần chuẩn bị dữ liệu cho việc này bằng tidyr::pivot_longer().\n\nprepare_long_data <- function(data, vars_to_long, vars_labels,\n    names_to = \"variable\", values_to = \"value\") {\n    data %>%\n        pivot_longer(\n            any_of(vars_to_long),\n            names_to = names_to, values_to = values_to\n        ) %>%\n        mutate(\n            !!names_to := factor(!!sym(names_to),\n                levels = vars_to_long, labels = vars_labels)\n        )\n}\n\nprepare_long_data(d, c(\"hb\", \"rbc\"), c(\"Hb\", \"RBC\")) %>% head() %>% kable()\n\n\n\n\nstt\ngioi\ndo_tuoi\nvariable\nvalue\n\n\n\n\n1\nNu\n>45\nHb\n122.10\n\n\n1\nNu\n>45\nRBC\n3.93\n\n\n2\nNam\n>45\nHb\n127.70\n\n\n2\nNam\n>45\nRBC\n4.95\n\n\n3\nNu\n>45\nHb\n121.50\n\n\n3\nNu\n>45\nRBC\n3.89\n\n\n\n\n\nVới dữ liệu dạng dọc như thế này, chúng ta có thể sử dụng các hàm nêu trên, nhưng đổi tên các biến. Mình bỏ hàm vẽ đường thẳng trung bình vì trong trường hợp này bạn sẽ cần viết lại hàm (sử dụng hàm ggplot2::stat_summary()).\n\nvars_to_long <- c(\"hb\", \"rbc\")\nvars_labels <- c(\n    \"Nồng độ hemoglobin (g/L)\",\n    \"Số lượng hồng cầu (T/L)\"\n)\nvar_name <- \"value\"\nvar_label <- \"\"\nbar_fill <- \"#afac9c\"\nvar_subgroup <- \"variable\"\n\nprepare_long_data(d, vars_to_long, vars_labels) %>%\n    plot_create() %>%\n    plot_histogram(var_name, var_label, bar_fill) %>%\n    plot_subgroup(var_subgroup)\n\n\n\n\n\n\n5.3.3 Vẽ nhiều biểu đồ cho nhiều biến dưới nhóm\nTrong trường hợp muốn vẽ biểu đồ dưới nhóm cho cả giới và tuổi, chúng ta có thể làm như sau.\n\nlibrary(purrr)\n\nprepare_data_multisubgroups <- function(data, vars_subgroup, new_subgroup,\n    sep = \", \") {\n    paste_list <- lift(paste)\n    new_levels <- map(vars_subgroup, ~ levels(pull(d, .x))) %>%\n        cross() %>%\n        map(~ paste_list(.x, sep = sep)) %>%\n        unlist()\n    data %>%\n        unite(!!new_subgroup, any_of(vars_subgroup), sep = sep) %>%\n        mutate(\n            !!new_subgroup := factor(!!sym(new_subgroup), levels = new_levels)\n        )\n}\n\nprepare_data_multisubgroups(d, c(\"gioi\", \"do_tuoi\"), \"gioi_tuoi\") %>% head() %>% kable()\n\n\n\n\nstt\ngioi_tuoi\nhb\nrbc\n\n\n\n\n1\nNu, >45\n122.1\n3.93\n\n\n2\nNam, >45\n127.7\n4.95\n\n\n3\nNu, >45\n121.5\n3.89\n\n\n4\nNam, <18\n140.0\n3.98\n\n\n5\nNam, >45\n146.7\n5.14\n\n\n6\nNu, <18\n139.9\n3.32\n\n\n\n\n\n\nvars_subgroup <- c(\"gioi\", \"do_tuoi\")\nvar_name <- \"rbc\"\nvar_label <- \"Số lượng hồng cầu (T/L)\"\nbar_fill <- \"#afac9c\"\nvar_subgroup <- \"gioi_tuoi\"\n\nprepare_data_multisubgroups(d, vars_subgroup, var_subgroup) %>%\n    plot_create() %>%\n    plot_histogram(var_name, var_label, bar_fill) %>%\n    plot_subgroup(var_subgroup)\n\n\n\n\nHi vọng với những ví dụ trên đây, các bạn có thể mường tượng được vai trò của hàm trong việc chia một nhiệm vụ lớn thành nhiều công việc nhỏ. Hàm không chỉ giúp chúng ta viết các đoạn lệnh gọn gàng hơn và tránh lặp lại các lệnh nhiều lần, nó còn giúp chúng ta tùy biến trong lập trình thông qua việc ghép các công việc khác nhau lại với nhau."
  },
  {
    "objectID": "06_names.html#vector-có-tên",
    "href": "06_names.html#vector-có-tên",
    "title": "6  Hàm names()",
    "section": "6.1 Vector có tên",
    "text": "6.1 Vector có tên\nTrong ví dụ dưới đây chúng ta có tên các biến và nhãn của chúng.\n\nvars <- c(\"age\", \"sex\", \"bmi\")\nvarnames <- c(\"Tuổi\", \"Giới\", \"BMI\")\n\nprint(vars)\n\n[1] \"age\" \"sex\" \"bmi\"\n\nprint(varnames)\n\n[1] \"Tuổi\" \"Giới\" \"BMI\" \n\n\nLàm thế nào để chúng ta lấy được nhãn của biến age? Bạn sẽ cần sử dụng hàm which(). Trước hết hãy xem hàm which() làm gì.\n\nwhich(vars == \"age\")\n\n[1] 1\n\n\nNhư bạn đã thấy, hàm which() trả về danh sách các vị trí trong vector thỏa mãn điều kiện được khai báo trong hàm. Vậy để lấy nhãn của biến age, chúng ta sẽ làm như sau.\n\nvarnames[which(vars == \"age\")]\n\n[1] \"Tuổi\"\n\n\nR cung cấp một cách tham chiếu khác tới vector bằng tên gọi. Hãy “đặt tên” cho vector varnames và xem sự khác biệt.\n\nnames(varnames) <- vars\nprint(varnames)\n\n   age    sex    bmi \n\"Tuổi\" \"Giới\"  \"BMI\" \n\n\nChúng ta có một vector trong đó mỗi phần tử có một tên gọi riêng. Bây giờ chúng ta có thể tham chiếu tới từng phần tử bằng tên gọi tương tự như dictionary trong Python. Tuy nhiên, khác với Python, tất cả các tên trong R sẽ được tự động chuyển về kiểu kí tự.\n\nvarnames[\"age\"]\n\n   age \n\"Tuổi\" \n\n\nNếu muốn xóa tên, chúng ta sẽ gán cho nó giá trị NULL.\n\nnames(varnames) <- NULL\nvarnames\n\n[1] \"Tuổi\" \"Giới\" \"BMI\" \n\n\n\n6.1.1 Khai báo tên trực tiếp khi khai báo vector\nBạn cũng có thể khai báo tên ngay khi tạo vector. Nếu trong tên có kí tự đặc biệt không phải chữ cái, số, và dấu gạch nối (_), bạn có thể bao chúng trong cặp dấu ngoặc kép (\"\") hoặc phẩy trên trái (\\``).\n\nc(\n    hb_d0 = \"Hemoglobin (baseline)\",\n    \"rbc d1\" = \"Red blood cell (day 1)\",\n    `plt d2` = \"Platelet (day 2)\"\n)\n\n                   hb_d0                   rbc d1                   plt d2 \n \"Hemoglobin (baseline)\" \"Red blood cell (day 1)\"       \"Platelet (day 2)\" \n\n\n\n\n6.1.2 Tạo tên gọi theo quy luật\nBạn không cần phải gõ tên cho từng phần tử nếu các phần tử có tên tuân theo một quy luật. Chẳng hạn, chúng ta có một danh sách các mốc thời gian, và tên gọi của mốc thời gian “X” là “Ngày X”.\n\ntimepoints <- seq_len(7)\nnames(timepoints) <- paste0(\"Ngày \", timepoints)\ntimepoints\n\nNgày 1 Ngày 2 Ngày 3 Ngày 4 Ngày 5 Ngày 6 Ngày 7 \n     1      2      3      4      5      6      7 \n\n\n\n\n6.1.3 Subset danh sách\nQuay trở lại với ví dụ đầu tiên, làm sao để lấy được danh sách nhãn của một số biến?\n\nvars_subset <- c(\"age\", \"bmi\")\nvarnames[vars %in% vars_subset]\n\n[1] \"Tuổi\" \"BMI\" \n\n\nVới tên gọi, bạn có thể dùng hàm lặp thay vì dùng toán tử matching %in%.\n\nnames(varnames) <- vars\nsapply(vars_subset, function(x) varnames[x], USE.NAMES = FALSE)\n\n   age    bmi \n\"Tuổi\"  \"BMI\""
  },
  {
    "objectID": "06_names.html#list-có-tên",
    "href": "06_names.html#list-có-tên",
    "title": "6  Hàm names()",
    "section": "6.2 List có tên",
    "text": "6.2 List có tên\nBạn cũng có thể đặt cho danh sách. Thông thường chúng ta đặt tên cho danh sách trong lúc khai báo danh sách.\n\nlist(\n    id = c(1, 2, 3),\n    initials = c(\"PKL\", \"LHS\", \"MTNN\")\n)\n\n$id\n[1] 1 2 3\n\n$initials\n[1] \"PKL\"  \"LHS\"  \"MTNN\"\n\n\nNếu danh sách không có tên (ví dụ, được tạo ra từ hàm lặp), bạn có thể dùng hàm names() để đặt tên.\n\nno_reps <- c(1, 4, 2)\nresults <- lapply(no_reps, function(x) rep(1, x))\nprint(results)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1 1 1 1\n\n[[3]]\n[1] 1 1\n\nnames(results) <- no_reps\nprint(results)\n\n$`1`\n[1] 1\n\n$`4`\n[1] 1 1 1 1\n\n$`2`\n[1] 1 1\n\n\nHoặc chúng ta đặt tên cho vector no_reps trước. Danh sách trả về sẽ sử dụng tên của vector này.\n\nnames(no_reps) <- c(\"1 element\", \"4 elements\", \"2 elements\")\nlapply(no_reps, function(x) rep(1, x))\n\n$`1 element`\n[1] 1\n\n$`4 elements`\n[1] 1 1 1 1\n\n$`2 elements`\n[1] 1 1\n\n\nHãy xem một ví dụ “nâng cao” để thấy giá trị của việc đặt tên. Trong ví dụ này, chúng ta sẽ viết một hàm để thống kê theo nhiều cách khác nhau, cách thức thống kê sẽ được quy định đối số method của hàm.\n\nget_stats <- function(data, method = \"mean\") {\n    switch(method,\n        \"mean\" = sprintf(\"%.2f (%.2f)\", mean(data, na.rm = TRUE), sd(data, na.rm = TRUE)),\n        \"median\" = sprintf(\"%.2f [%.2f, %.2f]\", median(data, na.rm = TRUE), quantile(data, .25, na.rm = TRUE), quantile(data, .75, na.rm = TRUE)),\n        \"minmax\" = sprintf(\"%.2f-%.2f\", min(data, na.rm = TRUE), max(data, na.rm = TRUE)),\n    )\n}\n\nset.seed(0)\ndata <- rgamma(100, 2, 1)\n\nget_stats(data)\n\n[1] \"1.85 (1.10)\"\n\nget_stats(data, \"median\")\n\n[1] \"1.63 [1.01, 2.55]\"\n\nget_stats(data, \"minmax\")\n\n[1] \"0.15-5.34\"\n\n\nThay vì việc gọi hàm get_stats() 3 lần, chúng ta có thể sử dụng vòng lặp để cung cấp thông tin tự động cho đối số method.\n\nmethods <- c(\"mean\", \"minmax\", \"median\")\nsapply(methods, function(x) get_stats(data, x))\n\n               mean              minmax              median \n      \"1.85 (1.10)\"         \"0.15-5.34\" \"1.63 [1.01, 2.55]\" \n\n\nHàm này còn có thể mạnh hơn nữa khi lặp lại trên nhiều biến.\n\ndata2 <- data.frame(\n    d0 = rgamma(100, 2, 1),\n    d1 = rgamma(100, 3, 1.2),\n    d2 = rgamma(100, 3.5, 2)\n)\n\nprint(head(data2))\n\n         d0       d1        d2\n1 2.4998077 1.560672 1.1883247\n2 1.4112553 2.871651 2.6535716\n3 0.3700219 0.856785 1.8037974\n4 1.1291394 3.366226 0.5186375\n5 0.9739632 4.965208 2.3719618\n6 2.2215693 2.454356 1.4778128\n\nvars_to_get_stats <- c(\"d0\", \"d1\", \"d2\")\nsapply(vars_to_get_stats,\n    function(x) sapply(methods, function(y) get_stats(data2[[x]], y))\n) |> t() |> as.data.frame()   # Đổi hàng và cột cho nhau\n\n          mean    minmax            median\nd0 1.85 (1.39) 0.17-5.66 1.46 [0.81, 2.53]\nd1 2.56 (1.41) 0.35-7.07 2.44 [1.47, 3.52]\nd2 1.74 (1.09) 0.20-6.61 1.44 [1.00, 2.27]\n\n\nBạn có thể đi xa thêm một bước bằng cách đặt tên cho các vector methods và vars_to_get_stats. Chúng ta sẽ có một bảng tổng kết với tên gọi hoàn chỉnh sẵn sàng cho việc xuất bản.\n\nnames(methods) <- c(\"Mean (SD)\", \"Min-Max\", \"Median [Q1, Q3]\")\nnames(vars_to_get_stats) <- c(\"Trước mổ\", \"Sau mổ - ngày 1\", \"Sau mổ - ngày 2\")\nsapply(vars_to_get_stats,\n    function(x) sapply(methods, function(y) get_stats(data2[[x]], y))\n) |> t() |> knitr::kable()\n\n\n\n\n\nMean (SD)\nMin-Max\nMedian [Q1, Q3]\n\n\n\n\nTrước mổ\n1.85 (1.39)\n0.17-5.66\n1.46 [0.81, 2.53]\n\n\nSau mổ - ngày 1\n2.56 (1.41)\n0.35-7.07\n2.44 [1.47, 3.52]\n\n\nSau mổ - ngày 2\n1.74 (1.09)\n0.20-6.61\n1.44 [1.00, 2.27]"
  },
  {
    "objectID": "06_names.html#giải-nén-tên-gọi-như-đối-số-trong-hàm",
    "href": "06_names.html#giải-nén-tên-gọi-như-đối-số-trong-hàm",
    "title": "6  Hàm names()",
    "section": "6.3 Giải nén tên gọi như đối số trong hàm",
    "text": "6.3 Giải nén tên gọi như đối số trong hàm\nNếu đã làm việc với thư viện dplyr, chắc hẳn bạn đã từng biết cú pháp của hàm rename(): rename(<tên_mới> = <tên_cũ>). Cá nhân mình thấy đây là một cú pháp ngớ ngẩn (logic thông thường là <tên_cũ> = <tên_mới>), nhưng dù là cú pháp nào thì bạn sẽ phải gõ bằng tay. Để tự động hóa việc này, chúng ta có thể sử dụng toán tử “ba chấm than” (!!!) để “giải nén” một vector có tên, tương tự như kĩ thuật dictionary unpacking (**kwargs) trong Python.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndata2 %>% rename(!!!vars_to_get_stats) %>% head()\n\n   Trước mổ Sau mổ - ngày 1 Sau mổ - ngày 2\n1 2.4998077        1.560672       1.1883247\n2 1.4112553        2.871651       2.6535716\n3 0.3700219        0.856785       1.8037974\n4 1.1291394        3.366226       0.5186375\n5 0.9739632        4.965208       2.3719618\n6 2.2215693        2.454356       1.4778128\n\n\nTương tự, bạn có thể thiết kế data dictionary để recode cho biến (sử dụng hàm dplyr::recode()).\n\ndatadict <- data.frame(\n    var = c(\"sex\", \"sex\", \"has_insurance\", \"has_insurance\"),\n    code = c(1, 2, 0, 1),\n    value = c(\"Female\", \"Male\", \"No\", \"Yes\")\n)\n\ndatadict\n\n            var code  value\n1           sex    1 Female\n2           sex    2   Male\n3 has_insurance    0     No\n4 has_insurance    1    Yes\n\n\n\nd <- data.frame(\n    sex = sample(c(1, 2), 10, replace = TRUE),\n    has_insurance = sample(c(0, 1), 10, replace = TRUE)\n) %>% tibble::as.tibble()\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\nd\n\n# A tibble: 10 × 2\n     sex has_insurance\n   <dbl>         <dbl>\n 1     2             1\n 2     2             0\n 3     2             0\n 4     2             0\n 5     1             1\n 6     1             1\n 7     2             1\n 8     2             0\n 9     1             1\n10     1             0\n\n\n\nrecode_var <- function(d, datadict, varname) {\n    # Lập từ điển recode cho biến\n    codes <- datadict %>% filter(var == varname) %>% pull(code)\n    values <- datadict %>% filter(var == varname) %>% pull(value)\n    names(values) <- codes\n\n    # Recode cho biến\n    # Lưu ý: cú pháp của recode() ngược với rename()\n    # recode(<giá_trị_cũ> = <giá_trị_mới>)\n    d %>% mutate(!!varname := recode_factor(!!sym(varname), !!!values))\n}\n\nrecode_var(d, datadict, \"sex\")\n\n# A tibble: 10 × 2\n   sex    has_insurance\n   <fct>          <dbl>\n 1 Male               1\n 2 Male               0\n 3 Male               0\n 4 Male               0\n 5 Female             1\n 6 Female             1\n 7 Male               1\n 8 Male               0\n 9 Female             1\n10 Female             0"
  }
]